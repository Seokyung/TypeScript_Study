## [2-4] 타입 별칭과 인덱스 시그니쳐

### 타입 별칭 (Type Alias)
- 타입 별칭을 이용하면 변수를 선언하듯 타입을 별도로 정의할 수 있음
- `type 타입이름 = 타입` 형태로 타입 정의

```typescript
type User = {
  id: number;
  name: string;
  nickname: string;
  birth: string;
  bio: string;
  location: string;
};
```

- 동일한 스코프에 동일한 이름의 타입 별칭을 사용하는 것은 불가함
- 그러나 함수 블록과 같이 스코프가 다르다면 중복된 이름으로 여러 개의 타입 별칭을 사용할 수 있음

```typescript
type User = {
  id: number;
  name: string;
  nickname: string;
  birth: string;
  bio: string;
  location: string;
};

function func() {
  // func 함수 블록 안의 User 타입과 블록 밖의 User 타입은 서로 다른 타입
  type User = {
    id: number;
    password: string;
  };

  let funcUser: User = {
    id: 9999,
    password: '9999qwer',
  }
}
```

---

### 인덱스 시그니쳐 (Index Signature)
- key와 value의 규칙을 기준으로 객체의 타입을 정의할 수 있는 문법
- 객체 타입을 유연하게 정의할 수 있도록 해줌
- `[key: 타입]: 타입` 형태로 key와 value의 타입 정의

```typescript
type CountryCodes = {
  [key: string]: string;
}

let countryCodes: CountryCodes = {
  Korea: 'ko',
  UnitedStates: 'us',
  Japan: 'jp',
};
```

- 반드시 가져야 하는 프로퍼티가 있는 경우 따로 정의해주어야 함
- 인덱스 시그니쳐를 사용하면서 동시에 추가적인 프로퍼티를 또 정의할 때에는 인덱스 시그니쳐의 value 타입과 직접 추가한 프로퍼티의 value 타입이 호환되거나 일치해야 함

```typescript
type CountryStringAndNumberCodes = {
  [key: string]: number;
  Korea: number;

  // [Error] 'Japan' 형식의 'string' 속성을 'string' 인덱스 유형 'number'에 할당할 수 없습니다.
  // Japan: string;
}

let countryStringAndNumberCodes: CountryStringAndNumberCodes = {
  Korea: 410,
};
```